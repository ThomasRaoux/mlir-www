<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::bufferization Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">15.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1bufferization.html">bufferization</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::bufferization Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1bufferization_1_1func__ext"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization_1_1func__ext.html">func_ext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html">AnalysisState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html" title="AnalysisState provides a variety of helper functions for dealing with tensor values. ">AnalysisState</a> provides a variety of helper functions for dealing with tensor values.  <a href="classmlir_1_1bufferization_1_1AnalysisState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1BufferizationAliasInfo.html">BufferizationAliasInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmlir_1_1bufferization_1_1BufferizationAliasInfo.html" title="The BufferizationAliasInfo class maintains a list of buffer aliases and equivalence classes to suppor...">BufferizationAliasInfo</a> class maintains a list of buffer aliases and equivalence classes to support bufferization.  <a href="classmlir_1_1bufferization_1_1BufferizationAliasInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for BufferizableOpInterface-based bufferization.  <a href="structmlir_1_1bufferization_1_1BufferizationOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationState.html" title="BufferizationState provides helper functions for performing bufferization rewrites and handling memre...">BufferizationState</a> provides helper functions for performing bufferization rewrites and handling memref buffers.  <a href="structmlir_1_1bufferization_1_1BufferizationState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html">BufferizeTypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper type converter class that automatically populates the relevant materializations and type conversions for bufferization.  <a href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1BufferPlacementAllocs.html">BufferPlacementAllocs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple analysis that detects allocation operations.  <a href="classmlir_1_1bufferization_1_1BufferPlacementAllocs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1BufferPlacementTransformationBase.html">BufferPlacementTransformationBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for all BufferPlacement transformations.  <a href="classmlir_1_1bufferization_1_1BufferPlacementTransformationBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1DialectAnalysisState.html">DialectAnalysisState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dialect-specific analysis state.  <a href="structmlir_1_1bufferization_1_1DialectAnalysisState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State for analysis-enabled bufferization.  <a href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for analysis-enabled bufferization.  <a href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1OpFilter.html">OpFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9f555e6310adbe13cf6fd0163a345f65"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a9f555e6310adbe13cf6fd0163a345f65">AnchorMatchFn</a> = std::function&lt; bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;)&gt;</td></tr>
<tr class="memdesc:a9f555e6310adbe13cf6fd0163a345f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that matches anchor OpOperands for AllocTensorOp elimination.  <a href="#a9f555e6310adbe13cf6fd0163a345f65">More...</a><br /></td></tr>
<tr class="separator:a9f555e6310adbe13cf6fd0163a345f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad8a6459f58b1a5a6772110aac8d93d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#afad8a6459f58b1a5a6772110aac8d93d">RewriteFn</a> = std::function&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;)&gt;</td></tr>
<tr class="memdesc:afad8a6459f58b1a5a6772110aac8d93d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that rewrites matched anchors.  <a href="#afad8a6459f58b1a5a6772110aac8d93d">More...</a><br /></td></tr>
<tr class="separator:afad8a6459f58b1a5a6772110aac8d93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afbf6d54f9e3c10b9003b66b6224b28bf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bf">BufferRelation</a> { <a class="el" href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bfa6adf97f83acf6453d4a6a4b1070f3754">BufferRelation::None</a>, 
<a class="el" href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bfaafd102579f64c98e96d92a7424130605">BufferRelation::Equivalent</a>
 }<tr class="memdesc:afbf6d54f9e3c10b9003b66b6224b28bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify fine-grain relationship between buffers to enable more analysis.  <a href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bf">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:afbf6d54f9e3c10b9003b66b6224b28bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa24e592182e0b88ede8e85dbc3dcac5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aa24e592182e0b88ede8e85dbc3dcac5e">isFunctionArgument</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:aa24e592182e0b88ede8e85dbc3dcac5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the given value is a <a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block. ">BlockArgument</a> of a func::FuncOp.  <a href="#aa24e592182e0b88ede8e85dbc3dcac5e">More...</a><br /></td></tr>
<tr class="separator:aa24e592182e0b88ede8e85dbc3dcac5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05561ae5b9cceea1c45832340484ad6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a05561ae5b9cceea1c45832340484ad6b">replaceOpWithBufferizedValues</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values)</td></tr>
<tr class="memdesc:a05561ae5b9cceea1c45832340484ad6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace an op with replacement values.  <a href="#a05561ae5b9cceea1c45832340484ad6b">More...</a><br /></td></tr>
<tr class="separator:a05561ae5b9cceea1c45832340484ad6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39be4ef4ade941b1a0092ab453b38455"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a39be4ef4ade941b1a0092ab453b38455">lookupBuffer</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Value.html">Value</a> tensor, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a39be4ef4ade941b1a0092ab453b38455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup the buffer for the given value.  <a href="#a39be4ef4ade941b1a0092ab453b38455">More...</a><br /></td></tr>
<tr class="separator:a39be4ef4ade941b1a0092ab453b38455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91366abfb8d491ea5701260487518959"><td class="memTemplParams" colspan="2">template&lt;typename OpTy , typename... Args&gt; </td></tr>
<tr class="memitem:a91366abfb8d491ea5701260487518959"><td class="memTemplItemLeft" align="right" valign="top">OpTy&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a91366abfb8d491ea5701260487518959">replaceOpWithNewBufferizedOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a91366abfb8d491ea5701260487518959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace an op with a new op.  <a href="#a91366abfb8d491ea5701260487518959">More...</a><br /></td></tr>
<tr class="separator:a91366abfb8d491ea5701260487518959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba55edae716ab18fa6fe171c8ea804d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a7ba55edae716ab18fa6fe171c8ea804d">getMemRefType</a> (<a class="el" href="classmlir_1_1TensorType.html">TensorType</a> tensorType, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, MemRefLayoutAttrInterface layout={}, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={})</td></tr>
<tr class="memdesc:a7ba55edae716ab18fa6fe171c8ea804d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="namespacemlir_1_1MemRefType.html">MemRefType</a> to which the <code>tensorType</code> can be bufferized.  <a href="#a7ba55edae716ab18fa6fe171c8ea804d">More...</a><br /></td></tr>
<tr class="separator:a7ba55edae716ab18fa6fe171c8ea804d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c07f1ba6f98c79df9c8b52f9aeb22d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a70c07f1ba6f98c79df9c8b52f9aeb22d">getMemRefTypeWithFullyDynamicLayout</a> (<a class="el" href="classmlir_1_1TensorType.html">TensorType</a> tensorType, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={})</td></tr>
<tr class="memdesc:a70c07f1ba6f98c79df9c8b52f9aeb22d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a MemRef type with fully dynamic layout.  <a href="#a70c07f1ba6f98c79df9c8b52f9aeb22d">More...</a><br /></td></tr>
<tr class="separator:a70c07f1ba6f98c79df9c8b52f9aeb22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29bb08b5c9d4ede97bebe82842e7f18d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a29bb08b5c9d4ede97bebe82842e7f18d">getMemRefTypeWithStaticIdentityLayout</a> (<a class="el" href="classmlir_1_1TensorType.html">TensorType</a> tensorType, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={})</td></tr>
<tr class="memdesc:a29bb08b5c9d4ede97bebe82842e7f18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a MemRef type with a static identity layout (i.e., no layout map).  <a href="#a29bb08b5c9d4ede97bebe82842e7f18d">More...</a><br /></td></tr>
<tr class="separator:a29bb08b5c9d4ede97bebe82842e7f18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61676c20aa976168728d6c185d141739"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a61676c20aa976168728d6c185d141739">createAllocDeallocOps</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, bool onlyLeakingAllocs=false, bool *changed=nullptr)</td></tr>
<tr class="memdesc:a61676c20aa976168728d6c185d141739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create alloc/dealloc ops as specified in the bufferization options.  <a href="#a61676c20aa976168728d6c185d141739">More...</a><br /></td></tr>
<tr class="separator:a61676c20aa976168728d6c185d141739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf648dc804a1dcc39379e036051dbf82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#acf648dc804a1dcc39379e036051dbf82">castOrReallocMemRefValue</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>, MemRefType type)</td></tr>
<tr class="memdesc:acf648dc804a1dcc39379e036051dbf82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to cast the given ranked MemRef-typed value to the given ranked MemRef type.  <a href="#acf648dc804a1dcc39379e036051dbf82">More...</a><br /></td></tr>
<tr class="separator:acf648dc804a1dcc39379e036051dbf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ba4ab9f113b6bf377e6deb3d245050"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a20ba4ab9f113b6bf377e6deb3d245050">foldToMemrefToTensorPair</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, ToMemrefOp toMemref, bool allowSameType=true)</td></tr>
<tr class="memdesc:a20ba4ab9f113b6bf377e6deb3d245050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to fold to_memref(to_tensor(x)).  <a href="#a20ba4ab9f113b6bf377e6deb3d245050">More...</a><br /></td></tr>
<tr class="separator:a20ba4ab9f113b6bf377e6deb3d245050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac320de6b3d970a7f070bc8c0e75abaab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ac320de6b3d970a7f070bc8c0e75abaab">eliminateAllocTensors</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html">bufferization::AnalysisState</a> &amp;state, <a class="el" href="namespacemlir_1_1bufferization.html#a9f555e6310adbe13cf6fd0163a345f65">AnchorMatchFn</a> anchorMatchFunc, <a class="el" href="namespacemlir_1_1bufferization.html#afad8a6459f58b1a5a6772110aac8d93d">RewriteFn</a> rewriteFunc)</td></tr>
<tr class="memdesc:ac320de6b3d970a7f070bc8c0e75abaab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to eliminate AllocTensorOps inside <code>op</code>.  <a href="#ac320de6b3d970a7f070bc8c0e75abaab">More...</a><br /></td></tr>
<tr class="separator:ac320de6b3d970a7f070bc8c0e75abaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80f4fb9eca73ea085bccb4acba65044"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ab80f4fb9eca73ea085bccb4acba65044">insertSliceAnchoredAllocTensorEliminationStep</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html">bufferization::AnalysisState</a> &amp;state)</td></tr>
<tr class="memdesc:ab80f4fb9eca73ea085bccb4acba65044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to eliminate AllocTensorOps inside <code>op</code> that are anchored on an InsertSliceOp, i.e., if it is eventually inserted into another tensor (and some other conditions are met).  <a href="#ab80f4fb9eca73ea085bccb4acba65044">More...</a><br /></td></tr>
<tr class="separator:ab80f4fb9eca73ea085bccb4acba65044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6223871e93de2dbc611e8e54c5e4fb3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a6223871e93de2dbc611e8e54c5e4fb3b">populateBufferizeMaterializationLegality</a> (<a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:a6223871e93de2dbc611e8e54c5e4fb3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks ops used by bufferization for type conversion materializations as "legal" in the given <a class="el" href="classmlir_1_1ConversionTarget.html" title="This class describes a specific conversion target. ">ConversionTarget</a>.  <a href="#a6223871e93de2dbc611e8e54c5e4fb3b">More...</a><br /></td></tr>
<tr class="separator:a6223871e93de2dbc611e8e54c5e4fb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22345dcd836dbc3216a89bbd4ce26821"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a22345dcd836dbc3216a89bbd4ce26821">populateEliminateBufferizeMaterializationsPatterns</a> (<a class="el" href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html">BufferizeTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a22345dcd836dbc3216a89bbd4ce26821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns to eliminate bufferize materializations.  <a href="#a22345dcd836dbc3216a89bbd4ce26821">More...</a><br /></td></tr>
<tr class="separator:a22345dcd836dbc3216a89bbd4ce26821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82764b104266bb60dc16ba990cfc5929"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a82764b104266bb60dc16ba990cfc5929">bufferizeOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html">AnalysisState</a> &amp;analysisState)</td></tr>
<tr class="memdesc:a82764b104266bb60dc16ba990cfc5929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferize <code>op</code> and its nested ops that implement <code>BufferizableOpInterface</code>.  <a href="#a82764b104266bb60dc16ba990cfc5929">More...</a><br /></td></tr>
<tr class="separator:a82764b104266bb60dc16ba990cfc5929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2eb90676228266b5cf038ee3565363f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ac2eb90676228266b5cf038ee3565363f">bufferizeOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:ac2eb90676228266b5cf038ee3565363f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferize <code>op</code> and its nested ops that implement <code>BufferizableOpInterface</code>.  <a href="#ac2eb90676228266b5cf038ee3565363f">More...</a><br /></td></tr>
<tr class="separator:ac2eb90676228266b5cf038ee3565363f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36c97b27b691ad7fcee01d70ca143a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ac36c97b27b691ad7fcee01d70ca143a9">getPartialBufferizationOptions</a> ()</td></tr>
<tr class="separator:ac36c97b27b691ad7fcee01d70ca143a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca77cc4e576e92e00fda27688d12ba31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aca77cc4e576e92e00fda27688d12ba31">bufferizeOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;bufferizationState, const <a class="el" href="classmlir_1_1bufferization_1_1OpFilter.html">OpFilter</a> *opFilter=nullptr)</td></tr>
<tr class="memdesc:aca77cc4e576e92e00fda27688d12ba31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferize <code>op</code> and its nested ops that implement <code>BufferizableOpInterface</code>.  <a href="#aca77cc4e576e92e00fda27688d12ba31">More...</a><br /></td></tr>
<tr class="separator:aca77cc4e576e92e00fda27688d12ba31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3e96855afce575c19b4fbae1921717"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a6a3e96855afce575c19b4fbae1921717">finalizeBuffers</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a6a3e96855afce575c19b4fbae1921717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize all buffer allocations: Create alloc/dealloc ops as specified by the bufferization options.  <a href="#a6a3e96855afce575c19b4fbae1921717">More...</a><br /></td></tr>
<tr class="separator:a6a3e96855afce575c19b4fbae1921717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa111ae7f728e7e3a776a2a67a177fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; memref::GlobalOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aaaa111ae7f728e7e3a776a2a67a177fb">getGlobalFor</a> (arith::ConstantOp constantOp, uint64_t alignment)</td></tr>
<tr class="separator:aaaa111ae7f728e7e3a776a2a67a177fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a195b54b8caf2857a41371be6348f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a31a195b54b8caf2857a41371be6348f0">analyzeOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;state)</td></tr>
<tr class="memdesc:a31a195b54b8caf2857a41371be6348f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze <code>op</code> and its nested ops.  <a href="#a31a195b54b8caf2857a41371be6348f0">More...</a><br /></td></tr>
<tr class="separator:a31a195b54b8caf2857a41371be6348f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fea54bba0c4c111425bdad3167e836"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a44fea54bba0c4c111425bdad3167e836">runOneShotBufferize</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a44fea54bba0c4c111425bdad3167e836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run One-Shot Bufferize on the given op: Analysis + Bufferization.  <a href="#a44fea54bba0c4c111425bdad3167e836">More...</a><br /></td></tr>
<tr class="separator:a44fea54bba0c4c111425bdad3167e836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c5406e7ae251a2920f3a7276ea9049"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ac2c5406e7ae251a2920f3a7276ea9049">analyzeModuleOp</a> (ModuleOp moduleOp, <a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;state)</td></tr>
<tr class="memdesc:ac2c5406e7ae251a2920f3a7276ea9049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze <code>moduleOp</code> and its nested ops.  <a href="#ac2c5406e7ae251a2920f3a7276ea9049">More...</a><br /></td></tr>
<tr class="separator:ac2c5406e7ae251a2920f3a7276ea9049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170154c42d0ff2796c7a7b63cc59bddb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a170154c42d0ff2796c7a7b63cc59bddb">bufferizeModuleOp</a> (ModuleOp moduleOp, const <a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;analysisState)</td></tr>
<tr class="memdesc:a170154c42d0ff2796c7a7b63cc59bddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferize <code>op</code> and its nested ops that implement <code>BufferizableOpInterface</code>.  <a href="#a170154c42d0ff2796c7a7b63cc59bddb">More...</a><br /></td></tr>
<tr class="separator:a170154c42d0ff2796c7a7b63cc59bddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01516f6d5024ab7f61f78049b938595e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a01516f6d5024ab7f61f78049b938595e">runOneShotModuleBufferize</a> (ModuleOp moduleOp, const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">bufferization::OneShotBufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a01516f6d5024ab7f61f78049b938595e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run One-Shot Module Bufferization on the given module.  <a href="#a01516f6d5024ab7f61f78049b938595e">More...</a><br /></td></tr>
<tr class="separator:a01516f6d5024ab7f61f78049b938595e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbadbbffeae2eddfac65c53b2f1cadba"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#adbadbbffeae2eddfac65c53b2f1cadba">createBufferDeallocationPass</a> ()</td></tr>
<tr class="memdesc:adbadbbffeae2eddfac65c53b2f1cadba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the BufferDeallocation pass to free all allocated buffers.  <a href="#adbadbbffeae2eddfac65c53b2f1cadba">More...</a><br /></td></tr>
<tr class="separator:adbadbbffeae2eddfac65c53b2f1cadba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9fe9c9234e2d22a86553a393f074d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a8e9fe9c9234e2d22a86553a393f074d8">deallocateBuffers</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a8e9fe9c9234e2d22a86553a393f074d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run buffer deallocation.  <a href="#a8e9fe9c9234e2d22a86553a393f074d8">More...</a><br /></td></tr>
<tr class="separator:a8e9fe9c9234e2d22a86553a393f074d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b99b019001e22f13cbb9adaf483febe"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a4b99b019001e22f13cbb9adaf483febe">createBufferHoistingPass</a> ()</td></tr>
<tr class="memdesc:a4b99b019001e22f13cbb9adaf483febe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that moves allocations upwards to reduce the number of required copies that are inserted during the BufferDeallocation pass.  <a href="#a4b99b019001e22f13cbb9adaf483febe">More...</a><br /></td></tr>
<tr class="separator:a4b99b019001e22f13cbb9adaf483febe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f24bfd4dabfbaa35cb099c0cc78480"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a94f24bfd4dabfbaa35cb099c0cc78480">createBufferLoopHoistingPass</a> ()</td></tr>
<tr class="memdesc:a94f24bfd4dabfbaa35cb099c0cc78480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that moves allocations upwards out of loops.  <a href="#a94f24bfd4dabfbaa35cb099c0cc78480">More...</a><br /></td></tr>
<tr class="separator:a94f24bfd4dabfbaa35cb099c0cc78480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbbddbfb4db56de847f081bd093a8fc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#abdbbddbfb4db56de847f081bd093a8fc">createBufferResultsToOutParamsPass</a> ()</td></tr>
<tr class="memdesc:abdbbddbfb4db56de847f081bd093a8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that converts memref function results to out-params.  <a href="#abdbbddbfb4db56de847f081bd093a8fc">More...</a><br /></td></tr>
<tr class="separator:abdbbddbfb4db56de847f081bd093a8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdc964c6ac7fb1952d2f01cec42cea3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aafdc964c6ac7fb1952d2f01cec42cea3">promoteBufferResultsToOutParams</a> (ModuleOp module)</td></tr>
<tr class="memdesc:aafdc964c6ac7fb1952d2f01cec42cea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace buffers that are returned from a function with an out parameter.  <a href="#aafdc964c6ac7fb1952d2f01cec42cea3">More...</a><br /></td></tr>
<tr class="separator:aafdc964c6ac7fb1952d2f01cec42cea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851c8abcfd5da0332cb96347484e750e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a851c8abcfd5da0332cb96347484e750e">createFinalizingBufferizePass</a> ()</td></tr>
<tr class="memdesc:a851c8abcfd5da0332cb96347484e750e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that finalizes a partial bufferization by removing remaining bufferization.to_tensor and bufferization.to_memref operations.  <a href="#a851c8abcfd5da0332cb96347484e750e">More...</a><br /></td></tr>
<tr class="separator:a851c8abcfd5da0332cb96347484e750e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a438c09e875e0ca7b69ac35bd415812"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a8a438c09e875e0ca7b69ac35bd415812">createOneShotBufferizePass</a> ()</td></tr>
<tr class="memdesc:a8a438c09e875e0ca7b69ac35bd415812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that bufferizes all ops that implement BufferizableOpInterface with One-Shot Bufferize.  <a href="#a8a438c09e875e0ca7b69ac35bd415812">More...</a><br /></td></tr>
<tr class="separator:a8a438c09e875e0ca7b69ac35bd415812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6db8eb7bfe512d8fdd2a3bcc14767b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a0e6db8eb7bfe512d8fdd2a3bcc14767b">createOneShotBufferizePass</a> (const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a0e6db8eb7bfe512d8fdd2a3bcc14767b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that bufferizes all ops that implement BufferizableOpInterface with One-Shot Bufferize and the specified bufferization options.  <a href="#a0e6db8eb7bfe512d8fdd2a3bcc14767b">More...</a><br /></td></tr>
<tr class="separator:a0e6db8eb7bfe512d8fdd2a3bcc14767b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd135f127fc250fb96fd3817f98ab9d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aadd135f127fc250fb96fd3817f98ab9d">createPromoteBuffersToStackPass</a> (<a class="el" href="classunsigned.html">unsigned</a> maxAllocSizeInBytes=1024, <a class="el" href="classunsigned.html">unsigned</a> maxRankOfAllocatedMemRef=1)</td></tr>
<tr class="memdesc:aadd135f127fc250fb96fd3817f98ab9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that promotes heap-based allocations to stack-based ones.  <a href="#aadd135f127fc250fb96fd3817f98ab9d">More...</a><br /></td></tr>
<tr class="separator:aadd135f127fc250fb96fd3817f98ab9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a9fdbeb428d3911ee0fbfbc3854283"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a62a9fdbeb428d3911ee0fbfbc3854283">createPromoteBuffersToStackPass</a> (std::function&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt; isSmallAlloc)</td></tr>
<tr class="memdesc:a62a9fdbeb428d3911ee0fbfbc3854283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that promotes heap-based allocations to stack-based ones.  <a href="#a62a9fdbeb428d3911ee0fbfbc3854283">More...</a><br /></td></tr>
<tr class="separator:a62a9fdbeb428d3911ee0fbfbc3854283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26904dacae283f5c12db5a623a6c8c07"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a26904dacae283f5c12db5a623a6c8c07">createAllocTensorEliminationPass</a> ()</td></tr>
<tr class="memdesc:a26904dacae283f5c12db5a623a6c8c07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that tries to eliminate alloc_tensor ops that are anchored on insert_slice ops.  <a href="#a26904dacae283f5c12db5a623a6c8c07">More...</a><br /></td></tr>
<tr class="separator:a26904dacae283f5c12db5a623a6c8c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2bfa7b904999fa85ab33b9c7ad28e0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aeb2bfa7b904999fa85ab33b9c7ad28e0">createBufferizationBufferizePass</a> ()</td></tr>
<tr class="memdesc:aeb2bfa7b904999fa85ab33b9c7ad28e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that bufferizes ops from the bufferization dialect.  <a href="#aeb2bfa7b904999fa85ab33b9c7ad28e0">More...</a><br /></td></tr>
<tr class="separator:aeb2bfa7b904999fa85ab33b9c7ad28e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aabacf83eaecd5d832fcb2337eab274"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a6aabacf83eaecd5d832fcb2337eab274">registerAllocationOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memdesc:a6aabacf83eaecd5d832fcb2337eab274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register external models for AllocationOpInterface.  <a href="#a6aabacf83eaecd5d832fcb2337eab274">More...</a><br /></td></tr>
<tr class="separator:a6aabacf83eaecd5d832fcb2337eab274"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a9f555e6310adbe13cf6fd0163a345f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f555e6310adbe13cf6fd0163a345f65">&#9670;&nbsp;</a></span>AnchorMatchFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1bufferization.html#a9f555e6310adbe13cf6fd0163a345f65">mlir::bufferization::AnchorMatchFn</a> = typedef std::function&lt;bool(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that matches anchor OpOperands for AllocTensorOp elimination. </p>
<p>If an <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation. ">OpOperand</a> is matched, the function should populate the SmallVector with all values that are needed during <code>RewriteFn</code> to produce the replacement value. </p>

<p class="definition">Definition at line <a class="el" href="AllocTensorElimination_8h_source.html#l00021">21</a> of file <a class="el" href="AllocTensorElimination_8h_source.html">AllocTensorElimination.h</a>.</p>

</div>
</div>
<a id="afad8a6459f58b1a5a6772110aac8d93d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad8a6459f58b1a5a6772110aac8d93d">&#9670;&nbsp;</a></span>RewriteFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1bufferization.html#afad8a6459f58b1a5a6772110aac8d93d">mlir::bufferization::RewriteFn</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that rewrites matched anchors. </p>

<p class="definition">Definition at line <a class="el" href="AllocTensorElimination_8h_source.html#l00024">24</a> of file <a class="el" href="AllocTensorElimination_8h_source.html">AllocTensorElimination.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="afbf6d54f9e3c10b9003b66b6224b28bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf6d54f9e3c10b9003b66b6224b28bf">&#9670;&nbsp;</a></span>BufferRelation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bf">mlir::bufferization::BufferRelation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specify fine-grain relationship between buffers to enable more analysis. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afbf6d54f9e3c10b9003b66b6224b28bfa6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afbf6d54f9e3c10b9003b66b6224b28bfaafd102579f64c98e96d92a7424130605"></a>Equivalent&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8h_source.html#l00319">319</a> of file <a class="el" href="BufferizableOpInterface_8h_source.html">BufferizableOpInterface.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac2c5406e7ae251a2920f3a7276ea9049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c5406e7ae251a2920f3a7276ea9049">&#9670;&nbsp;</a></span>analyzeModuleOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::analyzeModuleOp </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>moduleOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze <code>moduleOp</code> and its nested ops. </p>
<p>Bufferization decisions are stored in <code>state</code>. </p>

<p class="definition">Definition at line <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00384">384</a> of file <a class="el" href="OneShotModuleBufferize_8cpp_source.html">OneShotModuleBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir_1_1bufferization_1_1func__ext.html#a6476253be218223ddfd7569b0d0d3a5ea5019c2692a24497cb2e0b0f8885a0ceb">mlir::bufferization::func_ext::Analyzed</a>, <a class="el" href="FuncBufferizableOpInterfaceImpl_8h_source.html#l00064">mlir::bufferization::func_ext::FuncAnalysisState::analyzedFuncOps</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00932">analyzeOp()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00347">annotateOpsWithBufferizationMarkers()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00231">mlir::bufferization::BufferizationOptions::bufferizeFunctionBoundaries</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00259">equivalenceAnalysis()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="OneShotAnalysis_8h_source.html#l00140">mlir::bufferization::OneShotAnalysisState::getAliasInfo()</a>, <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00103">mlir::bufferization::func_ext::getFuncAnalysisState()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00288">getFuncOpsOrderedByCalls()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00456">mlir::bufferization::AnalysisState::getOptions()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00022">mlir::bufferization::func_ext::FuncAnalysisState::startFunctionAnalysis()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, and <a class="el" href="BufferizableOpInterface_8h_source.html#l00282">mlir::bufferization::BufferizationOptions::testAnalysisOnly</a>.</p>

<p class="reference">Referenced by <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00488">runOneShotModuleBufferize()</a>.</p>

</div>
</div>
<a id="a31a195b54b8caf2857a41371be6348f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a195b54b8caf2857a41371be6348f0">&#9670;&nbsp;</a></span>analyzeOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::analyzeOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze <code>op</code> and its nested ops. </p>
<p>Bufferization decisions are stored in <code>state</code>. </p>

<p class="definition">Definition at line <a class="el" href="OneShotAnalysis_8cpp_source.html#l00932">932</a> of file <a class="el" href="OneShotAnalysis_8cpp_source.html">OneShotAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="OneShotAnalysis_8cpp_source.html#l00851">annotateOpsWithBufferizationMarkers()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00886">assertDestinationPassingStyle()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00822">checkAliasInfoConsistency()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00788">equivalenceAnalysis()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00257">mlir::bufferization::OneShotAnalysisState::gatherUndefinedTensorUses()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00228">mlir::bufferization::OneShotAnalysisState::gatherYieldedTensors()</a>, <a class="el" href="OneShotAnalysis_8h_source.html#l00140">mlir::bufferization::OneShotAnalysisState::getAliasInfo()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00456">mlir::bufferization::AnalysisState::getOptions()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00426">mlir::bufferization::AnalysisState::hasDialectState()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00737">inPlaceAnalysis()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00572">mlir::Operation::walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00384">analyzeModuleOp()</a>, <a class="el" href="OneShotAnalysis_8h_source.html#l00140">mlir::bufferization::OneShotAnalysisState::getAliasInfo()</a>, <a class="el" href="AllocTensorElimination_8cpp_source.html#l00191">insertSliceAnchoredAllocTensorEliminationStep()</a>, and <a class="el" href="OneShotAnalysis_8cpp_source.html#l00981">runOneShotBufferize()</a>.</p>

</div>
</div>
<a id="a170154c42d0ff2796c7a7b63cc59bddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a170154c42d0ff2796c7a7b63cc59bddb">&#9670;&nbsp;</a></span>bufferizeModuleOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::bufferizeModuleOp </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>moduleOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">OneShotAnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>analysisState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bufferize <code>op</code> and its nested ops that implement <code>BufferizableOpInterface</code>. </p>
<p>Whether buffer copies are needed or not is queried from the given state. </p>

<p class="definition">Definition at line <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00434">434</a> of file <a class="el" href="OneShotModuleBufferize_8cpp_source.html">OneShotModuleBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00326">bufferizeOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00296">finalizeBuffers()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00362">foldMemRefCasts()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00288">getFuncOpsOrderedByCalls()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00456">mlir::bufferization::AnalysisState::getOptions()</a>, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html#a112d18a1625ccf9cd2e26515375c074eafe68fea92a39cf9ae6417326e038605f">mlir::bufferization::BufferizationOptions::InferLayoutMap</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00238">removeBufferizationAttributes()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00488">runOneShotModuleBufferize()</a>.</p>

</div>
</div>
<a id="a82764b104266bb60dc16ba990cfc5929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82764b104266bb60dc16ba990cfc5929">&#9670;&nbsp;</a></span>bufferizeOp() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::bufferizeOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html">AnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>analysisState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bufferize <code>op</code> and its nested ops that implement <code>BufferizableOpInterface</code>. </p>
<p>Whether buffer copies are needed or not is queried from <code>state</code>.</p>
<p>Note: If <code>allowUnknownOps</code> is set to false, bufferization fails when an unknown op (that does not implement <code>BufferizableOpInterface</code>) is found. No to_tensor/to_memref ops are inserted in that case.</p>
<p>Note: The layout map chosen to bufferize is the most dynamic canonical strided layout of the proper rank. This ensures compatibility with expected layouts after transformations. Combinations of memref.cast + canonicalization are responsible for clean ups. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00326">326</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="BufferizableOpInterface_8h_source.html#l00231">mlir::bufferization::BufferizationOptions::bufferizeFunctionBoundaries</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00296">finalizeBuffers()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00456">mlir::bufferization::AnalysisState::getOptions()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00426">mlir::bufferization::AnalysisState::hasDialectState()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00283">hasTensorSemantics()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00051">mlir::bufferization::OpFilter::isOpAllowed()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00077">mlir::bufferization::BufferizationOptions::isOpAllowed()</a>, <a class="el" href="Builders_8h_source.html#l00239">mlir::OpBuilder::Listener::notifyOperationInserted()</a>, <a class="el" href="PatternMatch_8h_source.html#l00555">mlir::RewriterBase::notifyOperationRemoved()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00434">bufferizeModuleOp()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00543">bufferizeOp()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00116">populateEliminateBufferizeMaterializationsPatterns()</a>, and <a class="el" href="OneShotAnalysis_8cpp_source.html#l00981">runOneShotBufferize()</a>.</p>

</div>
</div>
<a id="ac2eb90676228266b5cf038ee3565363f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2eb90676228266b5cf038ee3565363f">&#9670;&nbsp;</a></span>bufferizeOp() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::bufferizeOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bufferize <code>op</code> and its nested ops that implement <code>BufferizableOpInterface</code>. </p>
<p>Buffers are duplicated and copied before any tensor use that bufferizes to a memory write.</p>
<p>Note: This function bufferizes ops without utilizing analysis results. It can be used to implement partial bufferization passes. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00543">543</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00326">bufferizeOp()</a>.</p>

</div>
</div>
<a id="aca77cc4e576e92e00fda27688d12ba31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca77cc4e576e92e00fda27688d12ba31">&#9670;&nbsp;</a></span>bufferizeOp() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::bufferizeOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;&#160;</td>
          <td class="paramname"><em>bufferizationState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1bufferization_1_1OpFilter.html">OpFilter</a> *&#160;</td>
          <td class="paramname"><em>opFilter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bufferize <code>op</code> and its nested ops that implement <code>BufferizableOpInterface</code>. </p>
<p>Reuse an existing <code><a class="el" href="structmlir_1_1bufferization_1_1BufferizationState.html" title="BufferizationState provides helper functions for performing bufferization rewrites and handling memre...">BufferizationState</a></code>.</p>
<p>Note: This function overload is useful for extending the bufferization. </p>
<p>Check the result of bufferization. Return an error if an op was not bufferized, unless partial bufferization is allowed. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00404">404</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="BufferizableOpInterface_8h_source.html#l00227">mlir::bufferization::BufferizationOptions::allowUnknownOps</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00274">mlir::bufferization::BufferizationOptions::createDeallocs</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00231">mlir::Operation::emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00085">foldToMemrefToTensorPair()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00154">mlir::Operation::getContext()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00517">mlir::bufferization::BufferizationState::getOptions()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00621">mlir::Operation::getUses()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00283">hasTensorSemantics()</a>, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html#a112d18a1625ccf9cd2e26515375c074eafe68fea92a39cf9ae6417326e038605f">mlir::bufferization::BufferizationOptions::InferLayoutMap</a>, <a class="el" href="Sparsification_8cpp_source.html#l00283">isInPlace()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00051">mlir::bufferization::OpFilter::isOpAllowed()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="namespacemlir.html#a59fa9dd53c74f1ca73aa7ef263c94adca622a0c108b4c33e1cc5ed8a22db11cbc">mlir::PreOrder</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00572">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="acf648dc804a1dcc39379e036051dbf82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf648dc804a1dcc39379e036051dbf82">&#9670;&nbsp;</a></span>castOrReallocMemRefValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::bufferization::castOrReallocMemRefValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to cast the given ranked MemRef-typed value to the given ranked MemRef type. </p>
<p>Insert a reallocation + copy if it cannot be statically guaranteed that a direct cast would be valid.</p>
<p>E.g., when casting from a ranked MemRef type with dynamic layout to a ranked MemRef type with static layout, it is not statically known whether the cast will succeed or not. Such <code>memref.cast</code> ops may fail at runtime. This function never generates such casts and conservatively inserts a copy.</p>
<p>This function returns <code><a class="el" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4" title="Utility function to generate a LogicalResult. ">failure()</a></code> in case of unsupported casts. E.g., casts with differing element types or memory spaces. </p>

<p class="definition">Definition at line <a class="el" href="BufferizationOps_8cpp_source.html#l00025">25</a> of file <a class="el" href="BufferizationOps_8cpp_source.html">BufferizationOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00250">mlir::Type::cast()</a>, <a class="el" href="ConvertLaunchFuncToLLVMCalls_8cpp_source.html#l00065">copy()</a>, <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="Builders_8h_source.html#l00451">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Value_8cpp_source.html#l00026">mlir::Value::getLoc()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00805">mlir::getStridesAndOffset()</a>, <a class="el" href="Value_8h_source.html#l00118">mlir::Value::getType()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>.</p>

<p class="reference">Referenced by <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00039">mlir::bufferization::BufferizeTypeConverter::BufferizeTypeConverter()</a>, and <a class="el" href="BufferizationOps_8cpp_source.html#l00085">foldToMemrefToTensorPair()</a>.</p>

</div>
</div>
<a id="a61676c20aa976168728d6c185d141739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61676c20aa976168728d6c185d141739">&#9670;&nbsp;</a></span>createAllocDeallocOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::createAllocDeallocOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyLeakingAllocs</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>changed</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create alloc/dealloc ops as specified in the bufferization options. </p>
<p>If <code>onlyLeakingAlloc</code>, only those buffer allocations are processed for which no buffer deallocation can be created. <code>changed</code> is set to <code>true</code> if the IR was modified. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00510">510</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00051">mlir::WalkResult::advance()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00390">mlir::bufferization::BufferizationOptions::createAlloc()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00404">mlir::bufferization::BufferizationOptions::createDealloc()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00154">mlir::Operation::getContext()</a>, <a class="el" href="Block_8cpp_source.html#l00230">mlir::Block::getTerminator()</a>, <a class="el" href="Visitors_8h_source.html#l00050">mlir::WalkResult::interrupt()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00042">kBufferAllocationAttr</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00045">kSkipDeallocAttr</a>, <a class="el" href="Visitors_8h_source.html#l00052">mlir::WalkResult::skip()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00572">mlir::Operation::walk()</a>, and <a class="el" href="Visitors_8h_source.html#l00055">mlir::WalkResult::wasInterrupted()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00296">finalizeBuffers()</a>, and <a class="el" href="BufferizableOpInterface_8h_source.html#l00550">replaceOpWithNewBufferizedOp()</a>.</p>

</div>
</div>
<a id="a26904dacae283f5c12db5a623a6c8c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26904dacae283f5c12db5a623a6c8c07">&#9670;&nbsp;</a></span>createAllocTensorEliminationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createAllocTensorEliminationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that tries to eliminate alloc_tensor ops that are anchored on insert_slice ops. </p>

<p class="definition">Definition at line <a class="el" href="AllocTensorElimination_8cpp_source.html#l00270">270</a> of file <a class="el" href="AllocTensorElimination_8cpp_source.html">AllocTensorElimination.cpp</a>.</p>

</div>
</div>
<a id="adbadbbffeae2eddfac65c53b2f1cadba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbadbbffeae2eddfac65c53b2f1cadba">&#9670;&nbsp;</a></span>createBufferDeallocationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createBufferDeallocationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the BufferDeallocation pass to free all allocated buffers. </p>

<p class="definition">Definition at line <a class="el" href="BufferDeallocation_8cpp_source.html#l00702">702</a> of file <a class="el" href="BufferDeallocation_8cpp_source.html">BufferDeallocation.cpp</a>.</p>

</div>
</div>
<a id="a4b99b019001e22f13cbb9adaf483febe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b99b019001e22f13cbb9adaf483febe">&#9670;&nbsp;</a></span>createBufferHoistingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createBufferHoistingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that moves allocations upwards to reduce the number of required copies that are inserted during the BufferDeallocation pass. </p>

<p class="definition">Definition at line <a class="el" href="BufferOptimizations_8cpp_source.html#l00420">420</a> of file <a class="el" href="BufferOptimizations_8cpp_source.html">BufferOptimizations.cpp</a>.</p>

</div>
</div>
<a id="aeb2bfa7b904999fa85ab33b9c7ad28e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2bfa7b904999fa85ab33b9c7ad28e0">&#9670;&nbsp;</a></span>createBufferizationBufferizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createBufferizationBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that bufferizes ops from the bufferization dialect. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00258">258</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

</div>
</div>
<a id="a94f24bfd4dabfbaa35cb099c0cc78480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f24bfd4dabfbaa35cb099c0cc78480">&#9670;&nbsp;</a></span>createBufferLoopHoistingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createBufferLoopHoistingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that moves allocations upwards out of loops. </p>
<p>This avoids reallocations inside of loops. </p>

<p class="definition">Definition at line <a class="el" href="BufferOptimizations_8cpp_source.html#l00424">424</a> of file <a class="el" href="BufferOptimizations_8cpp_source.html">BufferOptimizations.cpp</a>.</p>

</div>
</div>
<a id="abdbbddbfb4db56de847f081bd093a8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdbbddbfb4db56de847f081bd093a8fc">&#9670;&nbsp;</a></span>createBufferResultsToOutParamsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createBufferResultsToOutParamsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that converts memref function results to out-params. </p>

<p class="definition">Definition at line <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00193">193</a> of file <a class="el" href="BufferResultsToOutParams_8cpp_source.html">BufferResultsToOutParams.cpp</a>.</p>

</div>
</div>
<a id="a851c8abcfd5da0332cb96347484e750e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851c8abcfd5da0332cb96347484e750e">&#9670;&nbsp;</a></span>createFinalizingBufferizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::bufferization::createFinalizingBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that finalizes a partial bufferization by removing remaining bufferization.to_tensor and bufferization.to_memref operations. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00272">272</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00030">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="a8a438c09e875e0ca7b69ac35bd415812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a438c09e875e0ca7b69ac35bd415812">&#9670;&nbsp;</a></span>createOneShotBufferizePass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createOneShotBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that bufferizes all ops that implement BufferizableOpInterface with One-Shot Bufferize. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00262">262</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

</div>
</div>
<a id="a0e6db8eb7bfe512d8fdd2a3bcc14767b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6db8eb7bfe512d8fdd2a3bcc14767b">&#9670;&nbsp;</a></span>createOneShotBufferizePass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createOneShotBufferizePass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that bufferizes all ops that implement BufferizableOpInterface with One-Shot Bufferize and the specified bufferization options. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00266">266</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

</div>
</div>
<a id="aadd135f127fc250fb96fd3817f98ab9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd135f127fc250fb96fd3817f98ab9d">&#9670;&nbsp;</a></span>createPromoteBuffersToStackPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createPromoteBuffersToStackPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>maxAllocSizeInBytes</em> = <code>1024</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>maxRankOfAllocatedMemRef</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that promotes heap-based allocations to stack-based ones. </p>
<p>Only buffers smaller than the provided size are promoted. Dynamic shaped buffers are promoted up to the given rank. </p>

<p class="definition">Definition at line <a class="el" href="BufferOptimizations_8cpp_source.html#l00428">428</a> of file <a class="el" href="BufferOptimizations_8cpp_source.html">BufferOptimizations.cpp</a>.</p>

</div>
</div>
<a id="a62a9fdbeb428d3911ee0fbfbc3854283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a9fdbeb428d3911ee0fbfbc3854283">&#9670;&nbsp;</a></span>createPromoteBuffersToStackPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createPromoteBuffersToStackPass </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;&#160;</td>
          <td class="paramname"><em>isSmallAlloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that promotes heap-based allocations to stack-based ones. </p>
<p>Only buffers smaller with <code>isSmallAlloc(alloc) == true</code> are promoted. </p>

<p class="definition">Definition at line <a class="el" href="BufferOptimizations_8cpp_source.html#l00434">434</a> of file <a class="el" href="BufferOptimizations_8cpp_source.html">BufferOptimizations.cpp</a>.</p>

</div>
</div>
<a id="a8e9fe9c9234e2d22a86553a393f074d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e9fe9c9234e2d22a86553a393f074d8">&#9670;&nbsp;</a></span>deallocateBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::deallocateBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run buffer deallocation. </p>

<p class="definition">Definition at line <a class="el" href="BufferDeallocation_8cpp_source.html#l00655">655</a> of file <a class="el" href="BufferDeallocation_8cpp_source.html">BufferDeallocation.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00051">mlir::WalkResult::advance()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00231">mlir::Operation::emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Visitors_8h_source.html#l00050">mlir::WalkResult::interrupt()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, <a class="el" href="BufferDeallocation_8cpp_source.html#l00083">validateSupportedControlFlow()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00572">mlir::Operation::walk()</a>, and <a class="el" href="Visitors_8h_source.html#l00055">mlir::WalkResult::wasInterrupted()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00296">finalizeBuffers()</a>, and <a class="el" href="BufferDeallocation_8cpp_source.html#l00083">validateSupportedControlFlow()</a>.</p>

</div>
</div>
<a id="ac320de6b3d970a7f070bc8c0e75abaab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac320de6b3d970a7f070bc8c0e75abaab">&#9670;&nbsp;</a></span>eliminateAllocTensors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::eliminateAllocTensors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html">bufferization::AnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1bufferization.html#a9f555e6310adbe13cf6fd0163a345f65">AnchorMatchFn</a>&#160;</td>
          <td class="paramname"><em>anchorMatchFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1bufferization.html#afad8a6459f58b1a5a6772110aac8d93d">RewriteFn</a>&#160;</td>
          <td class="paramname"><em>rewriteFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to eliminate AllocTensorOps inside <code>op</code>. </p>
<ul>
<li><code>rewriteFunc</code> generates the replacement for the AllocTensorOp.</li>
<li><p class="startli">Only AllocTensorOps that are anchored on a matching <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation. ">OpOperand</a> as per <code>anchorMatchFunc</code> are considered. "Anchored" means that there is a path on the reverse SSA use-def chain, starting from the <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation. ">OpOperand</a> and always following the aliasing <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation. ">OpOperand</a>, that eventually ends at a single AllocTensorOp.</p>
<p class="startli">An AllocTensorOp is replaced with the result of <code>rewriteFunc</code> if it is anchored on a matching <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation. ">OpOperand</a>. "Anchored" means that there is a path on the reverse SSA use-def chain, starting from the <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation. ">OpOperand</a> and always following the aliasing <a class="el" href="classmlir_1_1OpOperand.html" title="This class represents an operand of an operation. ">OpOperand</a>, that eventually ends at a single AllocTensorOp. </p>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="AllocTensorElimination_8cpp_source.html#l00101">101</a> of file <a class="el" href="AllocTensorElimination_8cpp_source.html">AllocTensorElimination.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00051">mlir::WalkResult::advance()</a>, <a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html#a363b343118770a171af4135e8f1f9ef6">mlir::bufferization::AnalysisState::areEquivalentBufferizedValues()</a>, <a class="el" href="Value_8h_source.html#l00100">mlir::Value::dyn_cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AllocTensorElimination_8cpp_source.html#l00057">findValidInsertionPoint()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00206">mlir::bufferization::AnalysisState::findValueInReverseUseDefChain()</a>, <a class="el" href="UseDefLists_8h_source.html#l00133">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00126">mlir::bufferization::AnalysisState::getAliasingOpOperand()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8cpp_source.html#l00026">mlir::Value::getLoc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00307">mlir::Operation::getOpOperands()</a>, <a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html#a979239d76f30a7319a7af788b4528f9c">mlir::bufferization::AnalysisState::isInPlace()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00245">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="Builders_8h_source.html#l00329">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="Visitors_8h_source.html#l00052">mlir::WalkResult::skip()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00572">mlir::Operation::walk()</a>, and <a class="el" href="Visitors_8h_source.html#l00055">mlir::WalkResult::wasInterrupted()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AllocTensorElimination_8cpp_source.html#l00191">insertSliceAnchoredAllocTensorEliminationStep()</a>.</p>

</div>
</div>
<a id="a6a3e96855afce575c19b4fbae1921717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3e96855afce575c19b4fbae1921717">&#9670;&nbsp;</a></span>finalizeBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::finalizeBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize all buffer allocations: Create alloc/dealloc ops as specified by the bufferization options. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00296">296</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00510">createAllocDeallocOps()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00274">mlir::bufferization::BufferizationOptions::createDeallocs</a>, <a class="el" href="BufferDeallocation_8cpp_source.html#l00655">deallocateBuffers()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00168">promoteBufferResultsToOutParams()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00290">mlir::bufferization::BufferizationOptions::promoteBufferResultsToOutParams</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00434">bufferizeModuleOp()</a>, and <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00326">bufferizeOp()</a>.</p>

</div>
</div>
<a id="a20ba4ab9f113b6bf377e6deb3d245050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ba4ab9f113b6bf377e6deb3d245050">&#9670;&nbsp;</a></span>foldToMemrefToTensorPair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::foldToMemrefToTensorPair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ToMemrefOp&#160;</td>
          <td class="paramname"><em>toMemref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowSameType</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to fold to_memref(to_tensor(x)). </p>
<p>If x's type and the result type of the to_memref op are different, a memref.cast is needed. </p>

<p class="definition">Definition at line <a class="el" href="BufferizationOps_8cpp_source.html#l00085">85</a> of file <a class="el" href="BufferizationOps_8cpp_source.html">BufferizationOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01413">mlir::RewritePatternSet::add()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00025">castOrReallocMemRefValue()</a>, <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00470">mlir::bufferization::BufferizationState::createAlloc()</a>, <a class="el" href="IR_2Types_8h_source.html#l00244">mlir::Type::dyn_cast()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00322">mlir::emitError()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00259">mlir::RewriterBase::eraseOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="MemRefDialect_8cpp_source.html#l00046">mlir::memref::findDealloc()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l00089">mlir::memref::foldMemRefCast()</a>, <a class="el" href="SideEffectInterfaces_8h_source.html#l00043">mlir::SideEffects::Effect::Base&lt; DerivedEffect, BaseEffect &gt;::get()</a>, <a class="el" href="SideEffectInterfaces_8h_source.html#l00089">mlir::SideEffects::Resource::Base&lt; DefaultResource &gt;::get()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00151">mlir::Operation::getBlock()</a>, <a class="el" href="Value_8cpp_source.html#l00026">mlir::Value::getLoc()</a>, <a class="el" href="Matchers_8h_source.html#l00356">mlir::m_ConstantInt()</a>, <a class="el" href="Matchers_8h_source.html#l00333">mlir::matchPattern()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00245">mlir::RewriterBase::replaceOp()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00355">replaceOpWithBufferizedValues()</a>, <a class="el" href="PatternMatch_8h_source.html#l00451">mlir::RewriterBase::replaceOpWithNewOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00068">mlir::succeeded()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, <a class="el" href="InterfaceSupport_8h_source.html#l00155">value</a>, and <a class="el" href="Verifier_8cpp_source.html#l00372">mlir::verify()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00404">bufferizeOp()</a>.</p>

</div>
</div>
<a id="aaaa111ae7f728e7e3a776a2a67a177fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa111ae7f728e7e3a776a2a67a177fb">&#9670;&nbsp;</a></span>getGlobalFor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; memref::GlobalOp &gt; mlir::bufferization::getGlobalFor </td>
          <td>(</td>
          <td class="paramtype">arith::ConstantOp&#160;</td>
          <td class="paramname"><em>constantOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BufferUtils_8cpp_source.html#l00149">149</a> of file <a class="el" href="BufferUtils_8cpp_source.html">BufferUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02947">mlir::TypeConverter::convertType()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="IR_2Region_8h_source.html#l00172">mlir::Region::getOps()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00484">mlir::Operation::getRegion()</a>.</p>

</div>
</div>
<a id="a7ba55edae716ab18fa6fe171c8ea804d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba55edae716ab18fa6fe171c8ea804d">&#9670;&nbsp;</a></span>getMemRefType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> mlir::bufferization::getMemRefType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TensorType.html">TensorType</a>&#160;</td>
          <td class="paramname"><em>tensorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefLayoutAttrInterface&#160;</td>
          <td class="paramname"><em>layout</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="namespacemlir_1_1MemRefType.html">MemRefType</a> to which the <code>tensorType</code> can be bufferized. </p>
<p>If possible, op bufferization implementations should not use this function and instead infer precise memref types for tensor results by themselves.</p>
<p>Unless a layout map was specified, <code>options.unknownTypeConverter</code> determines what kind of layout map will be used. For best composability (without copies), the fully dynamic layout map is used by default.</p>
<p>Note: Canonicalization patterns could clean up layout maps and infer more precise layout maps after bufferization. However, many possible canonicalizations are currently not implemented. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00567">567</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00250">mlir::Type::cast()</a>, <a class="el" href="IR_2Types_8h_source.html#l00244">mlir::Type::dyn_cast()</a>, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html#a112d18a1625ccf9cd2e26515375c074ea0f3baa042a8c5ed612112f76ddcf0db5">mlir::bufferization::BufferizationOptions::FullyDynamicLayoutMap</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00600">getMemRefTypeWithFullyDynamicLayout()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00623">getMemRefTypeWithStaticIdentityLayout()</a>, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html#a112d18a1625ccf9cd2e26515375c074eab40cf4eaa15e2d85ab3c530bad3686a0">mlir::bufferization::BufferizationOptions::IdentityLayoutMap</a>, and <a class="el" href="BufferizableOpInterface_8h_source.html#l00269">mlir::bufferization::BufferizationOptions::unknownTypeConversion</a>.</p>

<p class="reference">Referenced by <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00411">mlir::bufferization::func_ext::FuncOpInterface::bufferize()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02999">foldTransferInBoundsAttribute()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00345">mlir::bufferization::BufferizationState::getBufferType()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00263">lookupBuffer()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01985">CollapseShapeOpMemRefCastFolder::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02845">CanonicalizeSingleResultAffineMinMaxOp&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01263">parseGlobalMemrefOpTypeAndInitialValue()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02048">mlir::replaceForOpWithNewYields()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00550">replaceOpWithNewBufferizedOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02400">verifyMemoryOpIndexing()</a>, <a class="el" href="AMXDialect_8cpp_source.html#l00043">verifyMultShape()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l03718">verifyVectorMemoryOp()</a>.</p>

</div>
</div>
<a id="a70c07f1ba6f98c79df9c8b52f9aeb22d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c07f1ba6f98c79df9c8b52f9aeb22d">&#9670;&nbsp;</a></span>getMemRefTypeWithFullyDynamicLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> mlir::bufferization::getMemRefTypeWithFullyDynamicLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TensorType.html">TensorType</a>&#160;</td>
          <td class="paramname"><em>tensorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a MemRef type with fully dynamic layout. </p>
<p>If the given tensor type is unranked, return an unranked MemRef type. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00600">600</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00250">mlir::Type::cast()</a>, <a class="el" href="IR_2Types_8h_source.html#l00244">mlir::Type::dyn_cast()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00866">mlir::makeStridedLinearLayoutMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00411">mlir::bufferization::func_ext::FuncOpInterface::bufferize()</a>, <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00064">mlir::bufferization::func_ext::getBufferizedFunctionArgType()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00567">getMemRefType()</a>, and <a class="el" href="BufferizableOpInterface_8h_source.html#l00550">replaceOpWithNewBufferizedOp()</a>.</p>

</div>
</div>
<a id="a29bb08b5c9d4ede97bebe82842e7f18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29bb08b5c9d4ede97bebe82842e7f18d">&#9670;&nbsp;</a></span>getMemRefTypeWithStaticIdentityLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> mlir::bufferization::getMemRefTypeWithStaticIdentityLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TensorType.html">TensorType</a>&#160;</td>
          <td class="paramname"><em>tensorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a MemRef type with a static identity layout (i.e., no layout map). </p>
<p>If the given tensor type is unranked, return an unranked MemRef type. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00623">623</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00250">mlir::Type::cast()</a>, and <a class="el" href="IR_2Types_8h_source.html#l00244">mlir::Type::dyn_cast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00411">mlir::bufferization::func_ext::FuncOpInterface::bufferize()</a>, <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00064">mlir::bufferization::func_ext::getBufferizedFunctionArgType()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00567">getMemRefType()</a>, and <a class="el" href="BufferizableOpInterface_8h_source.html#l00550">replaceOpWithNewBufferizedOp()</a>.</p>

</div>
</div>
<a id="ac36c97b27b691ad7fcee01d70ca143a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac36c97b27b691ad7fcee01d70ca143a9">&#9670;&nbsp;</a></span>getPartialBufferizationOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> mlir::bufferization::getPartialBufferizationOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00549">549</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="BufferizableOpInterface_8h_source.html#l00227">mlir::bufferization::BufferizationOptions::allowUnknownOps</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00274">mlir::bufferization::BufferizationOptions::createDeallocs</a>, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html#a112d18a1625ccf9cd2e26515375c074eab40cf4eaa15e2d85ab3c530bad3686a0">mlir::bufferization::BufferizationOptions::IdentityLayoutMap</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, and <a class="el" href="BufferizableOpInterface_8h_source.html#l00269">mlir::bufferization::BufferizationOptions::unknownTypeConversion</a>.</p>

<p class="reference">Referenced by <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00116">populateEliminateBufferizeMaterializationsPatterns()</a>.</p>

</div>
</div>
<a id="ab80f4fb9eca73ea085bccb4acba65044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80f4fb9eca73ea085bccb4acba65044">&#9670;&nbsp;</a></span>insertSliceAnchoredAllocTensorEliminationStep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::insertSliceAnchoredAllocTensorEliminationStep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1AnalysisState.html">bufferization::AnalysisState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to eliminate AllocTensorOps inside <code>op</code> that are anchored on an InsertSliceOp, i.e., if it is eventually inserted into another tensor (and some other conditions are met). </p>
<p>Try to eliminate AllocTensorOps inside <code>op</code>.</p>
<p>An AllocTensorOp can be eliminated if it is eventually inserted into another tensor (and some other conditions are met).</p>
<p>E.g.: %0 = linalg.alloc_tensor %1 = linalg.fill(cst, %0) {inplace = [true]} %2 = tensor.insert_slice %1 into t[10][20][1]</p>
<p>AllocTensorOp elimination will try to fill t inplace instead of filling a new allocation %0 and inserting it into t. This is done by replacing the AllocTensorOp with:</p>
<p>%0 = tensor.extract_slice t[10][20][1]</p>
<p>The analysis looks for matching ExtractSliceOp/InsertSliceOp pairs and lets those bufferize inplace in the absence of other conflicts.</p>
<p>Starting from an InsertSliceOp, an AllocTensorOp at the end of the insert source's reverse use-def chain is eliminated if:</p><ul>
<li>On the reverse use-def chain path from the InsertSliceOp to the AllocTensorOp, all ops were decided to bufferize inplace and the buffer relation is "equivalent" (TODO: can be relaxed if needed).</li>
<li>The reverse use-def chain has exactly one end, which is the AllocTensorOp. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="AllocTensorElimination_8cpp_source.html#l00191">191</a> of file <a class="el" href="AllocTensorElimination_8cpp_source.html">AllocTensorElimination.cpp</a>.</p>

<p class="reference">References <a class="el" href="OneShotAnalysis_8cpp_source.html#l00932">analyzeOp()</a>, <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="AllocTensorElimination_8cpp_source.html#l00101">eliminateAllocTensors()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00154">mlir::Operation::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00095">mlir::Builder::getIndexAttr()</a>, <a class="el" href="UseDefLists_8h_source.html#l00037">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="DialectRegistry_8h_source.html#l00116">mlir::DialectRegistry::insert()</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>.</p>

</div>
</div>
<a id="aa24e592182e0b88ede8e85dbc3dcac5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24e592182e0b88ede8e85dbc3dcac5e">&#9670;&nbsp;</a></span>isFunctionArgument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::bufferization::isFunctionArgument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if the given value is a <a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block. ">BlockArgument</a> of a func::FuncOp. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00560">560</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00100">mlir::Value::dyn_cast()</a>.</p>

</div>
</div>
<a id="a39be4ef4ade941b1a0092ab453b38455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39be4ef4ade941b1a0092ab453b38455">&#9670;&nbsp;</a></span>lookupBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::bufferization::lookupBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>tensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lookup the buffer for the given value. </p>
<p>If the value was not bufferized yet, wrap it in a ToMemrefOp. Otherwise, it is the result of a ToTensorOp, from which the memref operand is returned.</p>
<p>Note: Use <code><a class="el" href="structmlir_1_1bufferization_1_1BufferizationState.html#a2a06a3a606d64a90ecbff3b0ee386c44" title="Return the buffer (memref) for a given OpOperand (tensor). ">BufferizationState::getBuffer</a></code> during bufferization. <code>lookupBuffer</code> is just for compatibility and gradual migration of bufferization patterns to BufferizableOpInterface-based bufferization. It does not insert any buffer copies. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00263">263</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Types_8h_source.html#l00244">mlir::Type::dyn_cast()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00254">ensureToMemrefOpIsValid()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8cpp_source.html#l00026">mlir::Value::getLoc()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00567">getMemRefType()</a>, <a class="el" href="Value_8h_source.html#l00118">mlir::Value::getType()</a>, and <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00115">setInsertionPointAfter()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizableOpInterface_8h_source.html#l00521">mlir::bufferization::BufferizationState::getAnalysisState()</a>, and <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00285">mlir::bufferization::BufferizationState::getBuffer()</a>.</p>

</div>
</div>
<a id="a6223871e93de2dbc611e8e54c5e4fb3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6223871e93de2dbc611e8e54c5e4fb3b">&#9670;&nbsp;</a></span>populateBufferizeMaterializationLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::bufferization::populateBufferizeMaterializationLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks ops used by bufferization for type conversion materializations as "legal" in the given <a class="el" href="classmlir_1_1ConversionTarget.html" title="This class describes a specific conversion target. ">ConversionTarget</a>. </p>
<p>This function should be called by all bufferization passes using <a class="el" href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html" title="A helper type converter class that automatically populates the relevant materializations and type con...">BufferizeTypeConverter</a> so that materializations work properly. One exception is bufferization passes doing "full" conversions, where it can be desirable for even the materializations to remain illegal so that they are eliminated, such as via the patterns in populateEliminateBufferizeMaterializationsPatterns. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00079">79</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00692">mlir::ConversionTarget::addLegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00403">mlir::OpConversionPattern&lt; SourceOp &gt;::OpConversionPattern()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01513">mlir::ConversionPatternRewriter::replaceOp()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a22345dcd836dbc3216a89bbd4ce26821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22345dcd836dbc3216a89bbd4ce26821">&#9670;&nbsp;</a></span>populateEliminateBufferizeMaterializationsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::bufferization::populateEliminateBufferizeMaterializationsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html">BufferizeTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns to eliminate bufferize materializations. </p>
<p>In particular, these are the tensor_load/buffer_cast ops. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00116">116</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l01413">mlir::RewritePatternSet::add()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00333">mlir::OpPassManager::addPass()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00052">mlir::bufferization::OpFilter::allowDialect()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00081">mlir::bufferization::OpFilter::allowOperation()</a>, <a class="el" href="OneShotAnalysis_8h_source.html#l00028">mlir::bufferization::OneShotBufferizationOptions::allowReturnAllocs</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00227">mlir::bufferization::BufferizationOptions::allowUnknownOps</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00304">mlir::bufferization::BufferizationOptions::alwaysAliasingWithDest</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00278">mlir::bufferization::BufferizationOptions::analysisFuzzerSeed</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03284">mlir::applyFullConversion()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00231">mlir::bufferization::BufferizationOptions::bufferizeFunctionBoundaries</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00326">bufferizeOp()</a>, <a class="el" href="Canonicalizer_8cpp_source.html#l00061">mlir::createCanonicalizerPass()</a>, <a class="el" href="CSE_8cpp_source.html#l00351">mlir::createCSEPass()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00274">mlir::bufferization::BufferizationOptions::createDeallocs</a>, <a class="el" href="LoopInvariantCodeMotion_8cpp_source.html#l00037">mlir::createLoopInvariantCodeMotionPass()</a>, <a class="el" href="OneShotAnalysis_8h_source.html#l00032">mlir::bufferization::OneShotBufferizationOptions::dropEquivalentFuncResults</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html#a112d18a1625ccf9cd2e26515375c074ea0f3baa042a8c5ed612112f76ddcf0db5">mlir::bufferization::BufferizationOptions::FullyDynamicLayoutMap</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00253">mlir::bufferization::BufferizationOptions::functionBoundaryTypeConversion</a>, <a class="el" href="PatternMatch_8h_source.html#l01389">mlir::RewritePatternSet::getContext()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00549">getPartialBufferizationOptions()</a>, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html#a112d18a1625ccf9cd2e26515375c074eab40cf4eaa15e2d85ab3c530bad3686a0">mlir::bufferization::BufferizationOptions::IdentityLayoutMap</a>, <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html#a112d18a1625ccf9cd2e26515375c074eafe68fea92a39cf9ae6417326e038605f">mlir::bufferization::BufferizationOptions::InferLayoutMap</a>, <a class="el" href="DialectRegistry_8h_source.html#l00116">mlir::DialectRegistry::insert()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03003">mlir::TypeConverter::isLegal()</a>, <a class="el" href="DialectConversion_8h_source.html#l00804">mlir::ConversionTarget::markUnknownOpDynamicallyLegal()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00201">mlir::bufferization::BufferizationOptions::opFilter</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00084">options</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00286">mlir::bufferization::BufferizationOptions::printConflicts</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00168">promoteBufferResultsToOutParams()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00290">mlir::bufferization::BufferizationOptions::promoteBufferResultsToOutParams</a>, <a class="el" href="BufferDeallocation_8cpp_source.html#l00691">registerAllocationOpInterfaceExternalModels()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00981">runOneShotBufferize()</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00488">runOneShotModuleBufferize()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00282">mlir::bufferization::BufferizationOptions::testAnalysisOnly</a>, and <a class="el" href="BufferizableOpInterface_8h_source.html#l00269">mlir::bufferization::BufferizationOptions::unknownTypeConversion</a>.</p>

</div>
</div>
<a id="aafdc964c6ac7fb1952d2f01cec42cea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafdc964c6ac7fb1952d2f01cec42cea3">&#9670;&nbsp;</a></span>promoteBufferResultsToOutParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::promoteBufferResultsToOutParams </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace buffers that are returned from a function with an out parameter. </p>
<p>Also update all call sites. </p>

<p class="definition">Definition at line <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00168">168</a> of file <a class="el" href="BufferResultsToOutParams_8cpp_source.html">BufferResultsToOutParams.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00117">updateCalls()</a>, <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00043">updateFuncOp()</a>, and <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00095">updateReturnOps()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00296">finalizeBuffers()</a>, and <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00116">populateEliminateBufferizeMaterializationsPatterns()</a>.</p>

</div>
</div>
<a id="a6aabacf83eaecd5d832fcb2337eab274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aabacf83eaecd5d832fcb2337eab274">&#9670;&nbsp;</a></span>registerAllocationOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::bufferization::registerAllocationOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register external models for AllocationOpInterface. </p>

<p class="definition">Definition at line <a class="el" href="BufferDeallocation_8cpp_source.html#l00691">691</a> of file <a class="el" href="BufferDeallocation_8cpp_source.html">BufferDeallocation.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00171">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00116">populateEliminateBufferizeMaterializationsPatterns()</a>, and <a class="el" href="BufferDeallocation_8cpp_source.html#l00083">validateSupportedControlFlow()</a>.</p>

</div>
</div>
<a id="a05561ae5b9cceea1c45832340484ad6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05561ae5b9cceea1c45832340484ad6b">&#9670;&nbsp;</a></span>replaceOpWithBufferizedValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::bufferization::replaceOpWithBufferizedValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace an op with replacement values. </p>
<p>The op is deleted. Tensor OpResults must be replaced with memref values. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00355">355</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="Value_8cpp_source.html#l00026">mlir::Value::getLoc()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00328">mlir::Operation::getNumResults()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00344">mlir::Operation::getOpResults()</a>, <a class="el" href="Value_8h_source.html#l00118">mlir::Value::getType()</a>, <a class="el" href="IR_2Types_8h_source.html#l00234">mlir::Type::isa()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00245">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="Builders_8h_source.html#l00343">mlir::OpBuilder::setInsertionPointAfter()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FuncBufferizableOpInterfaceImpl_8cpp_source.html#l00231">mlir::bufferization::func_ext::CallOpInterface::bufferize()</a>, <a class="el" href="BufferizationOps_8cpp_source.html#l00085">foldToMemrefToTensorPair()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00521">mlir::bufferization::BufferizationState::getAnalysisState()</a>, and <a class="el" href="BufferizableOpInterface_8h_source.html#l00550">replaceOpWithNewBufferizedOp()</a>.</p>

</div>
</div>
<a id="a91366abfb8d491ea5701260487518959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91366abfb8d491ea5701260487518959">&#9670;&nbsp;</a></span>replaceOpWithNewBufferizedOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpTy mlir::bufferization::replaceOpWithNewBufferizedOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace an op with a new op. </p>
<p>The new op must have the same number of results as the replaced op. The new op may not return any tensor values. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8h_source.html#l00550">550</a> of file <a class="el" href="BufferizableOpInterface_8h_source.html">BufferizableOpInterface.h</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00380">mlir::OpBuilder::create()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00510">createAllocDeallocOps()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00161">mlir::Operation::getLoc()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00567">getMemRefType()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00600">getMemRefTypeWithFullyDynamicLayout()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00623">getMemRefTypeWithStaticIdentityLayout()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00339">mlir::Operation::getResults()</a>, and <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00355">replaceOpWithBufferizedValues()</a>.</p>

</div>
</div>
<a id="a44fea54bba0c4c111425bdad3167e836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44fea54bba0c4c111425bdad3167e836">&#9670;&nbsp;</a></span>runOneShotBufferize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::runOneShotBufferize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">OneShotBufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run One-Shot Bufferize on the given op: Analysis + Bufferization. </p>

<p class="definition">Definition at line <a class="el" href="OneShotAnalysis_8cpp_source.html#l00981">981</a> of file <a class="el" href="OneShotAnalysis_8cpp_source.html">OneShotAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="OneShotAnalysis_8cpp_source.html#l00932">analyzeOp()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00326">bufferizeOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, and <a class="el" href="BufferizableOpInterface_8h_source.html#l00282">mlir::bufferization::BufferizationOptions::testAnalysisOnly</a>.</p>

<p class="reference">Referenced by <a class="el" href="OneShotAnalysis_8h_source.html#l00140">mlir::bufferization::OneShotAnalysisState::getAliasInfo()</a>, and <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00116">populateEliminateBufferizeMaterializationsPatterns()</a>.</p>

</div>
</div>
<a id="a01516f6d5024ab7f61f78049b938595e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01516f6d5024ab7f61f78049b938595e">&#9670;&nbsp;</a></span>runOneShotModuleBufferize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::runOneShotModuleBufferize </td>
          <td>(</td>
          <td class="paramtype">ModuleOp&#160;</td>
          <td class="paramname"><em>moduleOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1OneShotBufferizationOptions.html">bufferization::OneShotBufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run One-Shot Module Bufferization on the given module. </p>
<p>Performs a simple function call analysis to determine which function arguments are inplaceable. Then analyzes and bufferizes FuncOps one-by-one with One-Shot Bufferize. </p>

<p class="definition">Definition at line <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00488">488</a> of file <a class="el" href="OneShotModuleBufferize_8cpp_source.html">OneShotModuleBufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00384">analyzeModuleOp()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00231">mlir::bufferization::BufferizationOptions::bufferizeFunctionBoundaries</a>, <a class="el" href="OneShotModuleBufferize_8cpp_source.html#l00434">bufferizeModuleOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>, and <a class="el" href="BufferizableOpInterface_8h_source.html#l00282">mlir::bufferization::BufferizationOptions::testAnalysisOnly</a>.</p>

<p class="reference">Referenced by <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00116">populateEliminateBufferizeMaterializationsPatterns()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 3 2022 16:33:59 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
